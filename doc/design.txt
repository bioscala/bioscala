= Designing the BioScala library =

Scala is a strongly typed functional language, that allows for object
oriented programming (OOP). Too functional purists this is something
of a contradiction.  However, it does make sense for complex libraries
- OOP allows for partitioning of data and code.

Designing a library from scratch is a good opportunity to make
fundamental choices. OOP can easily be driven too far and can make
hierarchies of objects hard to maintain. With BioScala we opt for a
functional approach:

  BioScala aims for functional programming

OOP is used in the most minimalistic fashion to partition
functionality.

  BioScala uses OOP in a minimalistic fashion

Maybe an example will help. With functional programming we emphasize
immutable values and no side effects. We also design functions in a
way that they use '''basic''' objects, when possible.

So, it makes sense to have a Nucleotide class - which allows for
strong type checking. A Sequence has a list of nucleotides and a list
of attributes, like ID and descriptions.

Now we are to add transcription. Should it be part of the Sequence
class? In classic OOP design: yes. However, with BioScala we don't
think transcription is a part of a Sequence object. Rather than
cluttering Sequence - which is an object - we create a
SequenceTranslation object, which carries no state. The translate
method is without side effects. It takes as input a list of
nucleotide, and returns a fresh transcribed list of nucleotides.

For convenience we add a transcribe method to Sequence, which
delegates to the new function. Someone may wish to say
'seq.transcribe' - it should return a new transcribed Sequence. At
least, when there is a reason to, for example a deeper copy happens
of, for example, attributes. The rule is:

  A function should return the minimum complexity of objects (without
  losing information)

The main difference with a traditional OOP delegator pattern, like you
would write in Ruby or JAVA, is that the list of nucleotides get
passed to the function, as input. Traditionally a Sequence object
would be passed in.

What is the advantage? First, SequenceTranslation is not aware about
Sequence objects. So you can create an alternative implementation
easily. Second, the transcribe method is cleaner - it does not refer
to Sequence object internals.

== FastaReader

A similar example is FastaReader. Compare the BioScala implementation
with the current one in BioJAVA. In BioJAVA the FastaReader takes care
of reading a FASTA file, transforming it to BioJAVA Sequence objects
in ''memory'', and returns the type automatically (DNA, RNA,
Protein). It looks very attractive, as it takes care of everything.
However, it is not a flexible approach.

The BioScala FastaReader, in contrast, does very little. The FASTA
file is iterated, returning a Tuple every time. The tuple consists of
the record ID, description and sequence - as Strings. We can assume
that is the minimal layout of a FASTA record. Even if we no nothing of
the content.  The only state contained in the FastaReader object is the file
handle. You can use the same FastaReader for nucteotides, amino
acids, alignments, degenerated data etc.

FastaReader makes no real ''assumptions'' on the content of the FASTA
file.  It only split out records, based on lines starting with '>'.
And it splits out the ID from the description. If you encounter some
dirty file you can easily clean it up by filtering on the data, before
passing it into the Sequence object(s). Also it is trivially simple to
plug in a new implementation of a FastaReader.

FastaReader does not load everything in memory.

  BioScala does not read files in memory

Reading files in RAM is a big NO, in this age of Big Data.

== Support for ambiguous nucleotides ==

BioScala has several nucleotide classes which support data that is
pure (AGCT only), gapped (adds '-'), or has ambigous data like IUPAC.
If you use DNA.IUPACSequence over DNA.Sequence, you'll get type
checking for IUPAC. 

bio.Sequence[T] is the abstract base class for all Sequences.
DNA.Sequence supports Nucleotide - so only AGCT values.
DNA.IPACSequence supports IUPAC. And the IPACGappedSequence add gaps.
The design is similar for RNA and Protein sequences. Protein contains
support for Amino Acid and Codon type Sequences.

Support for translation etc. is mixed into the Sequence types.

The current implementation is somewhat inheritance based - mixed
traits may be a later improvement.

== Alignment ==

Alignments contain a list of Sequences. Each Sequence stores a list of:

  Nucleotide | Gap
  AminoAcid | Gap
  Codon | Gap

Where Gap is a bio.Symbol and Codon is an amino acid with matching
codon sequence. One way to handle it is to store a List[Symbol] that
supports a Gap and one of the other types in, for example,
GappedSequence[Codon]. The type safety is not really maintained at the
lowest level - as it is storing two different types. Still, the higher
interface, which constructs the Sequences, can be type safe.

Maybe we should support special IUPAC Gap types.  More complex Gaps can
store information as attributes, so we can do with a single symbol,
the dash. Thus the single types

  DNA.GappedIUPAC for DNA.GappedSequence
  Protein.GappedIUPAC for Protein.GappedSequence
  GappedCodon for GappedCodonSequence

and also

  DNA.GappedNucleotide for DNA.Sequence
  Protein.GappedAminoAcid for Protein.Sequence

are type safe. This implies that for these symbols we can safely use
the base abstract class bio.Sequence[T], rather than having a
specialised class.

Gapped Sequences share traits. One of them is to split the Sequence
into gapped and non-gapped sections. This functionality goes into
the RichGappedSequence trait.


